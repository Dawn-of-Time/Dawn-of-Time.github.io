<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言 | 常量与只读变量</title>
    <url>/post/f8f674bb.html</url>
    <content><![CDATA[<!-- 让表格居中显示的风格 -->
<style>
.center 
{
  width: auto;
  display: table;
  margin-left: auto;
  margin-right: auto;
}
</style>

<div class="note warning flat"><p>&emsp;&emsp;初学C语言时，应当重视常量相较于只读变量的内涵。</p>
</div>
<h2 id="一-常量的分类"><a href="#一-常量的分类" class="headerlink" title="一 常量的分类"></a>一 常量的分类</h2><h3 id="（一）-数值型常量"><a href="#（一）-数值型常量" class="headerlink" title="（一） 数值型常量"></a>（一） 数值型常量</h3><h4 id="1-整型常量"><a href="#1-整型常量" class="headerlink" title="1 整型常量"></a>1 整型常量</h4><p>&emsp;&emsp;整型常量是有且仅包含<b>八进制、十六进制、十进制</b>三种进制的整型常数，按照数值范围大小分为<b>长整型和短整型</b>。长整型和短整型各自又可分为<b>有符号整型和无符号整型</b>。<br>&emsp;&emsp;各进制的表达示例和<b>无符号短整型</b>数值范围如表1所示。当数值大小超过短整型数值范围时，必须用长整型来表示，在数值后缀<code>L</code>或<code>l</code>。</p>
<div class="center">

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">进制</th>
<th style="text-align:center">表达实例</th>
<th style="text-align:center">数值范围</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">八进制</td>
<td style="text-align:center">011 0277777<b>L</b></td>
<td style="text-align:center">[0,0177777]</td>
<td style="text-align:center">必须以<code>0</code>作为前缀</td>
</tr>
<tr>
<td style="text-align:center">十进制</td>
<td style="text-align:center">269 75535<b>L</b></td>
<td style="text-align:center">[0,65535]</td>
<td style="text-align:center">没有前缀</td>
</tr>
<tr>
<td style="text-align:center">十六进制</td>
<td style="text-align:center">0XAB 0X1FFFF<b>L</b></td>
<td style="text-align:center">[0x0,0xFFFF]</td>
<td style="text-align:center">必须以<code>0X</code>或<code>0x</code>作为前缀</td>
</tr>
</tbody>
</table>
</div>
<p><code>注：表达实例中的整型均为无符号整型，此处省略后缀U或u。</code><br>&lt;/div&gt;</p>
<p align="center">表1 整型常数的分类、表达实例和数值范围</p>

<div class="note info flat"><ul>
<li>不加限定的情况下，计算机默认整型是有符号整型。如果要表达无符号整型，需要后缀<code>U</code>或<code>u</code>；</li>
<li>八进制数和十六进制数极少用于表达有符号整型。表达有符号整型常用十进制，十进制有符号短整型的范围是[-32768,32767]，超出该范围时也应当用长整型的方式表达（后缀<code>L</code>或<code>l</code>）。</li>
</ul>
</div>
<h4 id="2-实型常量（浮点型常量）"><a href="#2-实型常量（浮点型常量）" class="headerlink" title="2 实型常量（浮点型常量）"></a>2 实型常量（浮点型常量）</h4><p>&emsp;&emsp;实型常量（浮点型常量）的表达形式有且仅包含<b>十进制数形式、指数形式</b>。例如：<code>0.0</code> <code>-2.3</code>；<code>56e5</code> <code>28E3</code>等。<br><div class="note warning flat"><p>用指数形式表达时有如下规定：</p>
<ul>
<li><code>e</code>或<code>E</code>前必须有数字；</li>
<li><code>e</code>或<code>E</code>后的指数必须为整数。</li>
</ul>
</div></p>
<h3 id="（二）-字符型常量"><a href="#（二）-字符型常量" class="headerlink" title="（二） 字符型常量"></a>（二） 字符型常量</h3><h4 id="1-字符常量"><a href="#1-字符常量" class="headerlink" title="1 字符常量"></a>1 字符常量</h4><p>&emsp;&emsp;使用单引号<b><code>&#39;&#39;</code></b>括起<b>单个</b>字符称为字符常量，例如<code>&#39;A&#39;</code> <code>&#39;@&#39;</code>。特殊地，单引号内以反斜杠<b><code>\</code></b>前缀的字符称为<b>转义字符</b>。常用转义字符如表2所示。<br><details class="toggle"><summary class="toggle-button" style>单击此处查看表2</summary><div class="toggle-content"><div class="center">

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">转义字符</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">\n</td>
<td style="text-align:center">换行</td>
</tr>
<tr>
<td style="text-align:center">\t</td>
<td style="text-align:center">水平制表</td>
</tr>
<tr>
<td style="text-align:center">\v</td>
<td style="text-align:center">垂直制表（影响打印机执行操作）</td>
</tr>
<tr>
<td style="text-align:center">\b</td>
<td style="text-align:center">退格</td>
</tr>
<tr>
<td style="text-align:center">\r</td>
<td style="text-align:center">回车</td>
</tr>
<tr>
<td style="text-align:center">\f</td>
<td style="text-align:center">换页（影响打印机执行操作）</td>
</tr>
<tr>
<td style="text-align:center">\\\</td>
<td style="text-align:center">反斜杠符</td>
</tr>
<tr>
<td style="text-align:center">\\’</td>
<td style="text-align:center">单引号符</td>
</tr>
<tr>
<td style="text-align:center">\\”</td>
<td style="text-align:center">双引号符</td>
</tr>
<tr>
<td style="text-align:center">\\?</td>
<td style="text-align:center">在书写连续多个问号时使用，防止他们被解析成三字母</td>
</tr>
<tr>
<td style="text-align:center">\a</td>
<td style="text-align:center">鸣铃</td>
</tr>
<tr>
<td style="text-align:center">\ddd</td>
<td style="text-align:center">1-3位八进制数所代表的字符，遵循ASCII码</td>
</tr>
<tr>
<td style="text-align:center">\xhh</td>
<td style="text-align:center">1-2位十六进制数所代表的字符，遵循ASCII码</td>
</tr>
</tbody>
</table>
</div>
<p>&lt;/div&gt;</p>
<p align="center">表2 常用转义字符表</p></div></div></details></p>
<h4 id="2-字符串常量"><a href="#2-字符串常量" class="headerlink" title="2 字符串常量"></a>2 字符串常量</h4><p>&emsp;&emsp;使用双引号<b><code>&quot;&quot;</code></b>括起<b>若干个</b>字符称为字符串常量。存储时，系统会自动在其末尾添加<b><code>\0</code></b>作为结束标志。<br><div class="note info flat"><ul>
<li><b><code>&quot;&quot;</code></b>也是字符串，其长度为0，称为空串；</li>
<li>结束标志<code>&#39;\0&#39;</code>源于转义字符<code>&#39;\ddd&#39;</code>，它在ASCII码表中对应<code>BLANK/NULL</code>。</li>
</ul>
</div></p>
<div class="note warning flat"><p>结束标志的存在非常重要，下例指出了其重要性：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> arr1[] = <span class="string">&#x27;abc&#x27;</span>;</span><br><span class="line">  <span class="type">char</span> arr2[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line">  <span class="type">char</span> arr3[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arr1); <span class="comment">//结果是abc</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arr2); <span class="comment">//结果是一串乱码</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, arr3); <span class="comment">//结果是abc</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;进一步研究发现，arr2因为缺少结束标志，在格式化输出的过程中，当字符<code>&#39;c&#39;</code>输出后，将在其后随机生成一个字符，直至随机生成的字符是结束标志<code>&#39;\0&#39;</code>。</p>
</div>
<h3 id="（三）-符号常量"><a href="#（三）-符号常量" class="headerlink" title="（三） 符号常量"></a>（三） 符号常量</h3><p>&emsp;&emsp;使用符号代替常量值。它使用宏定义命令<b><code>#define</code></b>来定义：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> 符号名称 常量值 <span class="comment">//例如#define PI 3.14</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="（四）-枚举常量"><a href="#（四）-枚举常量" class="headerlink" title="（四） 枚举常量"></a>（四） 枚举常量</h3><p>&emsp;&emsp;枚举常量使用关键字<b><code>enum</code></b>来定义：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  RED,  <span class="comment">//默认为0</span></span><br><span class="line">  YELLOW, <span class="comment">//默认为1</span></span><br><span class="line">  BLUE  <span class="comment">//默认为2</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;也可以自定义常量值。除非自定义，否则常量值总是递增的。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  RED,  <span class="comment">//默认为0</span></span><br><span class="line">  YELLOW = <span class="number">5</span>,</span><br><span class="line">  BLUE,  <span class="comment">//值为6</span></span><br><span class="line">  GREEN,  <span class="comment">//值为7</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="二-与只读变量的区别"><a href="#二-与只读变量的区别" class="headerlink" title="二 与只读变量的区别"></a>二 与只读变量的区别</h2><p>&emsp;&emsp;只读变量使用<b><code>const</code></b>来定义：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> PI = <span class="number">3.14</span>; </span><br></pre></td></tr></table></figure><br>&emsp;&emsp;只读变量是变量添加关键字<code>const</code>构成的，它和其它变量都存放在一个普通的区域，但是由编译器限定不允许被修改。而常量则存放在只读区域。他们有着本质的区别。下例将这样的区别更形象地体现。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 5</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//const int n = 5;</span></span><br><span class="line">  <span class="comment">//char arr1[n] = &#123;0&#125;; //报错</span></span><br><span class="line">  <span class="type">char</span> arr2[N] = &#123;<span class="number">0</span>&#125;; <span class="comment">//正确</span></span><br><span class="line">  <span class="type">char</span> arr3[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Fallibility</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 | 有符号整型与无符号整型 格式化输出十进制整型</title>
    <url>/post/ddd0df44.html</url>
    <content><![CDATA[<!-- 让表格居中显示的风格 -->
<style>
.center 
{
  width: auto;
  display: table;
  margin-left: auto;
  margin-right: auto;
}
</style>

<div class="note warning flat"><p>&emsp;&emsp;初学C语言时，对于整型的分类、存储和输出需厘清。</p>
</div>
<h2 id="一-有符号整型与无符号整型"><a href="#一-有符号整型与无符号整型" class="headerlink" title="一 有符号整型与无符号整型"></a>一 有符号整型与无符号整型</h2><h3 id="（一）-存储空间"><a href="#（一）-存储空间" class="headerlink" title="（一） 存储空间"></a>（一） 存储空间</h3><p>&emsp;&emsp;长整型、基本整型、短整型分别在内存中占据不同的字节数。在64位系统中，长整型和基本整型占据4个字节（32位），短整型占据2个字节（16位）。<br><div class="note info flat"><p>&emsp;&emsp;为了节约内存空间，在定义整型变量时建议采用占据字节数尽可能小的类型。</p>
</div></p>
<h3 id="（二）-符号位-原码、反码、补码"><a href="#（二）-符号位-原码、反码、补码" class="headerlink" title="（二） 符号位　原码、反码、补码"></a>（二） 符号位　原码、反码、补码</h3><p>&emsp;&emsp;在不加修饰的条件下，计算机默认整型为有符号整型。对于有符号整型而言，其对应二进制数的<b>最高位</b>是符号位，并且0表示正数，1表示负数。<br>&emsp;&emsp;二进制数的表示方法分为3种：<b>原码、反码、补码</b>。计算机总是以补码的形式存储数。对于正数而言，原码、反码、补码均相同，三者均表示数的真值。<b>对于负数而言，原码除符号位以外的位表示绝对值，反码是对原码除符号位以外的位取反的结果，补码是反码加1的结果。</b>如下例：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> f = ~e;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有符号数int：%d\n&quot;</span>, f); <span class="comment">//结果是 有符号数int：-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;在64位系统中，基本整型占据4个字节，因此变量e被赋值0后在内存中存储了32位0。按位取反后，32位0变为32位1。32位1的符号位是1，表示其为负数，其原码最高位（符号位）和最低位为1，其余位为0，所以真值为-1。</p>
<div class="note primary flat"><p><b>为什么计算机要使用补码来存储负数？</b><br>&emsp;&emsp;从原理上而言，加法和减法要依靠不同的电路实现，如果能将减法运算转化为加法运算，就能简化电路。同时，如果使用原码进行含负数的加法运算，其结果总是错误的。例如<code>(-2) + 1 = 1000 0010 + 0000 0001 = 1000 0011 = -3</code>（错误）。<br>&emsp;&emsp;计算机中的计数是可溢出的。譬如对1字节而言，有符号数的最大值是<code>0111 1111</code>，即127，再加1将溢出，使得最高位同时表示数值和符号，结果是<code>1000 0000</code>，为负数的补码；其原码为<code>1000 0000</code>（最高位仍然同时表示数值和符号），即-128。<br>&emsp;&emsp;一周共7天，周四至周六的计算可以是+2，也可以是-5，甚至可以是+9，-12，+17，-19等，这样的计算都是等价的，意味着对于可溢出系统而言，总能够使用加法代替减法运算。设可溢出系统的模为N（例如这里是7），那么加数和减数的和始终为N，这样的关系称为补数。<br>&emsp;&emsp;类似地，对于1字节而言，其模是<code>1 0000 0000</code>，若计算<code>(-2) + 1</code>，那么首先将-2转化为其补数。先取-2的绝对值2，然后用模减之，即<code>1 0000 0000 - 0000 0010 = 1111 1110</code>。因此<code>(-2) + 1 = 1111 1110 + 0000 0001 = 1111 1111(补) = -1</code>（正确）。</p>
</div>
<h3 id="（三）-有符号整型与无符号整型的定义和区别"><a href="#（三）-有符号整型与无符号整型的定义和区别" class="headerlink" title="（三） 有符号整型与无符号整型的定义和区别"></a>（三） 有符号整型与无符号整型的定义和区别</h3><p>&emsp;&emsp;不加修饰时，系统默认整型为有符号整型。无符号整型的表达在常量中为后缀U或u，在变量中则加关键字<code>unsigned</code>。它们的区别在于有符号整型的最高位是符号位，其余位表示数值，1字节的有符号整型的取值范围是[-128,127]；无符号整型每一位都表示数值，1字节的无符号整型的取值范围是[0,255]。</p>
<hr>
<h2 id="二-格式化输出十进制整型"><a href="#二-格式化输出十进制整型" class="headerlink" title="二 格式化输出十进制整型"></a>二 格式化输出十进制整型</h2><p>&emsp;&emsp;在变量中，整型分为长整型、基本整型和短整型，它们各自又分为有符号整型和无符号整型。每一种类型都有各自的格式控制字符串。就十进制而言，它们的格式控制字符串如表1所示。</p>
<div class="center">

<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">整型类型</th>
<th style="text-align:center">格式控制字符串</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">有符号长整型</td>
<td style="text-align:center">“%ld”</td>
</tr>
<tr>
<td style="text-align:center">无符号长整型</td>
<td style="text-align:center">“%lu”</td>
</tr>
<tr>
<td style="text-align:center">有符号基本整型</td>
<td style="text-align:center">“%d”</td>
</tr>
<tr>
<td style="text-align:center">无符号基本整型</td>
<td style="text-align:center">“%u”</td>
</tr>
<tr>
<td style="text-align:center">有符号短整型</td>
<td style="text-align:center">“%hd”</td>
</tr>
<tr>
<td style="text-align:center">无符号短整型</td>
<td style="text-align:center">“%hu”</td>
</tr>
</tbody>
</table>
</div>
<p>&lt;/div&gt;</p>
<p align="center">表1 十进制整型的格式控制字符串</p>

<p>&emsp;&emsp;以下就<b>有/无</b>符号<b>基本/短</b>整型为例，形象地体现了它们的区别。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;以下执行对0取反的操作：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> a = <span class="number">0</span>;<span class="comment">//4字节，32位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> b = ~a;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无符号数int：%u\n&quot;</span>, b); <span class="comment">//结果是 无符号数int：4294967295</span></span><br><span class="line">    <span class="comment">//printf(&quot;%d\n&quot;, b);  //结果是 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> c = <span class="number">0</span>;<span class="comment">//2字节，16位</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> d = ~c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;无符号数short：%hu\n&quot;</span>, d);  <span class="comment">//结果是 无符号数short：65535</span></span><br><span class="line">    <span class="comment">//printf(&quot;%hd\n&quot;, d);  //结果是 -1</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n以下是参照：\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> e = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> f = ~e;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有符号数int：%d\n&quot;</span>, f); <span class="comment">//结果是 有符号数int：-1</span></span><br><span class="line"></span><br><span class="line">    <span class="type">short</span> g = <span class="number">0</span>;</span><br><span class="line">    <span class="type">short</span> h = ~g;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;有符号数short：%hd\n&quot;</span>, h);  <span class="comment">//结果是 有符号数short：-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Fallibility</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 | 移位运算符</title>
    <url>/post/5663.html</url>
    <content><![CDATA[<div class="note info flat"><p>&emsp;&emsp;本博文的所有变量、数字、公式等均采用<code>katex</code>风格。</p>
</div>
<div class="note success flat"><p>&emsp;&emsp;<b>结论概览：</b><br>1 在无$1$溢出的情况下，左移（或右移）运算等价于乘以（或除以）$2^y$（$y$为移动位数，且不使得原数完全移出）。<br>2 在有$1$溢出的情况下（仅考虑右移运算）：</p>
<ul>
<li>2.1 对于非负数而言，右移运算等价于整除。</li>
<li>2.2 对于负数而言，右移运算等价于除法运算并向负无穷处取整。</li>
</ul>
</div>
<h1 id="一-移位运算符的含义"><a href="#一-移位运算符的含义" class="headerlink" title="一 移位运算符的含义"></a>一 移位运算符的含义</h1><p>&emsp;&emsp;移位运算符包含左移运算符<b><code>&lt;&lt;</code></b>和右移运算符<b><code>&gt;&gt;</code></b>。左移运算符是将一个二进制位的操作数按规定的移动位数向左移动，移出位舍弃，空位补$0$。右移运算符是将一个二进制位的操作数按规定的移动位数向右移动，移出位舍弃，<b>正数补$0$，负数补$1$</b>。它们是这样参与运算的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">操作数 移位运算符 移位位数</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;例如：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> a = <span class="number">4</span>;</span><br><span class="line">	a &lt;&lt;= <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;变量$a$被赋值$4$，换算为二进制数即<code>0000 0000 0000 0100</code>，左移$2$位后即<code>0000 0000 0001 0000</code>。</p>
<hr>
<h1 id="二-移位运算符的实质"><a href="#二-移位运算符的实质" class="headerlink" title="二 移位运算符的实质"></a>二 移位运算符的实质</h1><p>&emsp;&emsp;移位运算符实际上更改了数值对应的权重。<b>在无$1$溢出的情况下，设原来的权重是$2^x$，移动位数为$y$（不使得原数完全移出），则权重更改的结果是$2^{x±y}$（左移为加，右移为减）</b>。例如上例中数值1的权重是$2^2$，移位后更改为$2^{2+2}$。对每一位都执行移位的运算（以左移为例），那么在无$1$溢出的情况下（因而该二进制数的最高位一定为$0$，所以这里有符号数和无符号数没有区别），对二进制数$b_{15}b_{14}…b_1b_0$有：</p>
<script type="math/tex; mode=display">
\begin{aligned}
b_{15}b_{14}...b_1b_0 << y & = 2^{15}b_{15} + 2^{14}b_{14} + ... + 2^1b_1 + 2^0b_0 << y\\
& = 2^{15}b_{15-y} + 2^{14}b_{14-y} + ... + 2^yb_0 + 2^{y-1}×0 + ... + 2^1×0 + 2^0×0\\
& = 2^y(2^{15-y}b_{15-y} + 2^{14-y}b_{14-y} + ... + 2^1b_1 + 2^0b_0)\\
& = 2^yb_{15}b_{14}...b_1b_0\\
\end{aligned}</script><div class="note warning flat"><p>&emsp;&emsp;请注意以上计算建立在无$1$溢出的情况下，亦即$b_{15}b_{14}…b_{15-y+1}$每一位都为$0$。</p>
</div>
<p>&emsp;&emsp;因此，<b>在无$1$溢出的情况下，左移（或右移）运算等价于乘以（或除以）$2^y$（$y$为移动位数，且不使得原数完全移出）。</b><br>&emsp;&emsp;那么在有$1$溢出的情况下呢？因为左移运算结果具有个体差异性（如正负不确定），因此这里不予讨论。而对于右移运算，它的运算结果的符号总是不变，我们不妨对其进行以下测试：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">short</span> b = <span class="number">5</span>;</span><br><span class="line">	b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	<span class="type">short</span> c = <span class="number">-5</span>;</span><br><span class="line">	c &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%hd\n%hd\n&quot;</span>, b, c); <span class="comment">//结果是2 -3</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;变量$b$被赋值$5$，换算为二进制数，即<code>0000 0000 0000 0101</code>，右移$1$位后，末位的$1$被舍弃，即<code>0000 0000 0000 0010</code>，亦即$2$。换而言之，在除以$2$以后，右移运算使得不足$2$的部分被舍弃，也就是余数被舍弃。因此，<b>对于非负数而言，右移运算等价于整除。</b><br>&emsp;&emsp;变量c被赋值$-5$，换算为二进制数，即<code>1000 0000 0000 0101</code>，负数在内存中以补码的形式存储（<a href="https://www.dawn-of-time.top/post/ddd0df44.html">为什么？</a>），即<code>1111 1111 1111 1011</code>，右移$1$位后，末位的$1$被舍弃，即<code>1111 1111 1111 1101</code>，其原码为<code>1000 0000 0000 0011</code>，即$-3$。因此，<b>对于负数而言，右移运算等价于除法运算并向负无穷处取整。</b><br><div class="note primary flat"><p><b>如果对负数的右移仍存疑，以下推算可能有帮助。</b><br>&emsp;&emsp;以短整型（$16$位）为例。对二进制数<b>$b_{15}b_{14}…b_1b_0$</b>（其中$b_{15} = 1$，且其余位不全为$0$），记其十进制值</p>
<blockquote>
<script type="math/tex; mode=display">
D = -(2^{14}b_{14} + 2^{13}b_{13} + ... + 2^1b_1 + 2^0b_0)</script></blockquote>
<p>&emsp;&emsp;那么它的补码的十进制值为</p>
<blockquote>
<script type="math/tex; mode=display">
d = 2^{16} - (-D) = 2^{16} + D = 2^{16} - (2^{14}b_{14} + 2^{13}b_{13} + ... + 2^1b_1 + 2^0b_0)</script></blockquote>
<p>&emsp;&emsp;记其二进制数为<b>$c_{15}c_{14}…c_1c_0$</b>（其中$c_{15} = 1$，且其余位不全为$1$），则</p>
<blockquote>
<script type="math/tex; mode=display">
d = -(2^{14}c_{14} + 2^{13}c_{13} + ... + 2^1c_1 + 2^0c_0)</script></blockquote>
<p>&emsp;&emsp;设右移位数为$y$（不使得原数完全移出），则右移后二进制数变为$111…1c_{14}c_{13}…c_{y+1}c_y$，其十进制值</p>
<blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
d_0 & = -(2^{14} + 2^{13} + ... + 2^{14-y+1} + 2^{14-y}c_{14} + 2^{13-y}c_{13} + ... + 2^1c_{y+1} + 2^0c_y)\\
& = -(2^{15} - 2^{15-y} + 2^{14-y}c_{14} + 2^{13-y}c_{13} + ... + 2^1c_{y+1} + 2^0c_y)
\end{aligned}</script></blockquote>
<p>&emsp;&emsp;则移位后的原码的十进制值是</p>
<blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
D_0 & = 2^{16} - (-d_0)\\
& = 2^{16} + d_0\\
& = 2^{16} - (2^{15} - 2^{15-y} + 2^{14-y}c_{14} + 2^{13-y}c_{13} + ... + 2^1c_{y+1} + 2^0c_y)\\
& = 2^{16} - 2^{15} + 2^{15-y} - 2^{-y}(2^{14}c_{14} + 2^{13}c_{13} + ... + 2^{y+1}c_{y+1} + 2^yc_y)\\
& = 2^{15} + 2^{15-y} + 2^{-y}(d + 2^{y-1}c_{y-1} + 2^{y-2}c_{y-2} + ... + 2^1c_1 + 2^0c_0)
\end{aligned}</script></blockquote>
<p>&emsp;&emsp;如果将二进制数$c_{y-1}c_{y-2}…c_1c_0$的十进制值记为$d_1$（注意该二进制的符号始终为负），那么有</p>
<blockquote>
<script type="math/tex; mode=display">
d_1 = -(2^{y-1}c_{y-1} + 2^{y-2}c_{y-2} + ... + 2^1c_1 + 2^0c_0)</script></blockquote>
<p>&emsp;&emsp;因此</p>
<blockquote>
<script type="math/tex; mode=display">
\begin{aligned}
D_0 & = 2^{15} + 2^{15-y} + 2^{-y}(d + d_1)\\
& = 2^{15} + 2^{15-y} + 2^{-y}(2^{16} + D + d_1)\\
& = 2^{16-y} + 2^{15} + 2^{15-y} + 2^{-y}D + 2^{-y}d_1
\end{aligned}</script></blockquote>
<p>&emsp;&emsp;那么</p>
<blockquote>
<script type="math/tex; mode=display">
D = 2^y(D_0 - 2^{16-y} － 2^{15} - 2^{15-y} + 2^{-y}d_1)</script></blockquote>
<p>&emsp;&emsp;所以</p>
<blockquote>
<script type="math/tex; mode=display">
\frac{D}{D_0} = 2^y + \frac{-2^{16} - 2^{15+y} - 2^{15} + d_1}{D_0}</script></blockquote>
<p>&emsp;&emsp;根据计数可溢出的性质（<a href="https://www.dawn-of-time.top/post/ddd0df44.html">是什么？</a>），当$d_1$加或减$2^x$（$x&gt;y$且为整数），其值不改变。因此得移位前后原码的关系</p>
<blockquote>
<script type="math/tex; mode=display">
\frac{D}{D_0} = 2^y + \frac{d_1}{D_0}</script></blockquote>
<p>&emsp;&emsp;亦即</p>
<blockquote>
<script type="math/tex; mode=display">
D_0 = \frac{D - d_1}{2^y}</script></blockquote>
<p>&emsp;&emsp;其中，$D_0$是移出后原码，$D$是移出前原码，$d_1$是移出的原码对应的补码，$y$是右移位数，且其取值不使得原数完全移出。</p>
<p><b>检验这个结果</b></p>
<ul>
<li>对于$-5 &gt;&gt; 1$：$-5$的二进制数是<code>1000 0000 0000 0101</code>，右移$1$位后，移出的原码是<code>1</code>，对应的补码是<code>1</code>，那么得到移出后<script type="math/tex; mode=display">\frac{-5-1}{2^1} = -3</script></li>
<li>对于$-4 &gt;&gt; 2$：$-4$的二进制数是<code>1000 0000 0000 0100</code>，右移$2$位后，移出的原码是<code>00</code>，对应的补码是<code>00</code>，那么得到移出后<script type="math/tex; mode=display">\frac{-4-0}{2^2} = -1</script></li>
<li>对于$-11 &gt;&gt; 3$：$-11$的二进制数是<code>1000 0000 0000 1011</code>，右移$3$位后，移出的原码是<code>011</code>，对应的补码是<code>101</code>，那么得到移出后<script type="math/tex; mode=display">\frac{-11-5}{2^3} = -2</script></li>
</ul>
<p><b>通过尝试运行程序检验以上结果。</b></p>
</div></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Exploration</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 | 函数scanf()的使用</title>
    <url>/post/13be382b.html</url>
    <content><![CDATA[<h2 id="一-函数scanf-的基本含义"><a href="#一-函数scanf-的基本含义" class="headerlink" title="一 函数scanf()的基本含义"></a>一 函数scanf()的基本含义</h2><p>&emsp;&emsp;<code>scanf()</code>函数是这样定义的：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">scanf</span><span class="params">(格式字符串, 指针列表)</span>;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;它的返回值是成功读入的数据项数。如果遇到错误，返回值为0；如果遇到<code>end of file</code>（<code>end of file</code>在Windows系统中用<code>Ctrl+Z</code>代替），返回值为<code>EOF</code>（<code>EOF</code>是在<code>&lt;stdio.h&gt;</code>文件中宏定义的一个常量，值为-1）。可以从下例验证该结果。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当以空格或换行为分隔输入a b c d后，换行输出0 0 0 0 0；</span></span><br><span class="line"><span class="comment">// 当以空格或换行为分隔输入1 2 3 4后，换行输出1 2 3 4 4；</span></span><br><span class="line"><span class="comment">// 当以空格为分隔输入1 2 ^Z 3 4之后，换行输出1 2 0 0 2（实际上无论在^Z后输入什么都没有意义）；</span></span><br><span class="line"><span class="comment">// 当以换行为分隔输入1 2 ^Z ^Z之后，换行输出1 2 0 0 2；</span></span><br><span class="line"><span class="comment">// 当以换行为分隔输入^Z ^Z ^Z时，输出0 0 0 0 -1；</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d %d&quot;</span>, a, b, c, d, num);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><details class="toggle"><summary class="toggle-button" style>我对此存疑，但我目前无法解决这个问题。单击此处查看具体疑问</summary><div class="toggle-content"><ul>
<li><p><b>疑问一：是否输入过有效的内容影响退出时<code>^Z</code>所需次数。</b><br>&emsp;&emsp;通过上例可以知道，在以换行为分隔输入时，如果输入过有效内容，2次<code>^Z</code>可以结束输入，否则需要3次。</p>
</li>
<li><p><b>疑问二：不同的格式字符串可能会导致不同的结果。</b><br>&emsp;&emsp;如下例所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;ch);</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;在逐步调试下发现，以<code>&quot;%c&quot;</code>为格式字符串时需要2次<code>^Z</code>结束输入，而以<code>&quot;%d&quot;</code>为格式字符串时则需要3次<code>^Z</code>。<br>&emsp;&emsp;更进一步的，我做了一些研究来观察是否每一次<code>^Z</code>都有作用。<br>—&gt; 对于<code>&quot;%c&quot;</code>为格式字符串的情形：<br>&emsp;&emsp;在逐步调试下发现，如果以换行为分隔输入<code>^Z a</code>，观察到变量ch的值仍为0，这意味着第2次输入<code>^Z</code>无作用。</p>
</li>
</ul>
<p>—&gt; 对于<code>&quot;%d&quot;</code>为格式字符串的情形：<br>&emsp;&emsp;在逐步调试下发现，如果以换行为分隔输入<code>^Z 1</code>，观察到变量a的值变为1，这意味着第1次输入<code>^Z</code>无作用；如果以换行为分隔输入<code>^Z ^Z 1</code>，观察到变量a的值仍为0，这意味着第3次输入<code>^Z</code>无作用。</p>
<p>&emsp;&emsp;得到这样的结果令人百思不得其解，但我目前的水平还无法解决该问题。先将这样的疑问留在此处，我会在以后的学习过程中寻找契机解决它。<b>如果有知之者，还望在评论区不吝赐教。另：我使用的是64位Windows系统下的Visio Studio 2022专业版。</b></p>
</div></details></p>
<hr>
<h2 id="二-格式字符串的说明"><a href="#二-格式字符串的说明" class="headerlink" title="二 格式字符串的说明"></a>二 格式字符串的说明</h2><h3 id="（一）-抑制符（跳过符）"><a href="#（一）-抑制符（跳过符）" class="headerlink" title="（一） 抑制符（跳过符）"></a>（一） 抑制符（跳过符）</h3><p>&emsp;&emsp;在格式字符串中添加抑制符（<code>*</code>）使得读入的该数据被舍弃。如下例所示。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> num = <span class="built_in">scanf</span>(<span class="string">&quot;%d%*d%d&quot;</span>, &amp;a, &amp;b); <span class="comment">//输入1 2 3</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d %d&quot;</span>, a, b, num); <span class="comment">//得到 1 3 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="（二）-域宽"><a href="#（二）-域宽" class="headerlink" title="（二） 域宽"></a>（二） 域宽</h3><p>&emsp;&emsp;在格式字符串中添加十进制整数使以限制读入的数量。如果输入流数量超过域宽，则下次读入时从断点处开始。如下例所示。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%3d%4d&quot;</span>, &amp;a, &amp;b); <span class="comment">//输入123456789</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, a, b); <span class="comment">//得到123 4567 </span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;基本整型a读入的域宽是<code>3</code>，即读入<code>123</code>；基本整型b读入时，从断点处开始，即从<code>4</code>开始，其域宽为<code>4</code>，故读入<code>4567</code>。</p>
<h3 id="（三）-空白字符"><a href="#（三）-空白字符" class="headerlink" title="（三） 空白字符"></a>（三） 空白字符</h3><p>&emsp;&emsp;在格式字符串中所添加的空白字符<code>【空格（Space）、换行符（Newline）、制表符（Tab）】</code>和不添加的效果一致。如下例所示。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);     <span class="comment">//形式1</span></span><br><span class="line">	<span class="comment">//scanf(&quot;%d %d&quot;, &amp;a, &amp;b);  //形式2</span></span><br><span class="line">	<span class="comment">//scanf(&quot;%d\n%d&quot;, &amp;a, &amp;b); //形式3</span></span><br><span class="line">	<span class="comment">//scanf(&quot;%d\t%d&quot;, &amp;a, &amp;b); //形式4</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, a, b);	   <span class="comment">//以上4种形式的结果一致</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;在输入流中所添加的空白字符具有分隔两数据的功能，一般来说只读不存。但当以单字符形式读入时则取消了分隔功能，如下例所示。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> c = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%c%c%c&quot;</span>, &amp;a, &amp;b, &amp;c);<span class="comment">//输入m (Space) n</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%c %c %c&quot;</span>, a, b, c);<span class="comment">//得到m (Space) n，即a为字符m，b为空格字符，c为字符n</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;这意味着此时的空白字符不再具有分隔作用，而直接如同其他字符一般被读取和存储。</p>
<h3 id="（四）-非空白字符"><a href="#（四）-非空白字符" class="headerlink" title="（四） 非空白字符"></a>（四） 非空白字符</h3><p>&emsp;&emsp;在输入流中添加非空白字符意味着当在输入流中匹配到相同字符时不保存，未匹配到则停止读入（下次读入从断点处开始），如下例所示。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%dxy%d&quot;</span>, &amp;a, &amp;b);<span class="comment">//输入-情况1:123 456；情况2：123xy456</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, a, b);<span class="comment">//得到-情况1：123 0；情况2：123 456</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>在情况1下，当读入123并赋变量a后，由于未匹配到字符<code>x</code>，因此停止读取，故变量a为<code>123</code>，变量b仍为<code>0</code>；</li>
<li>在情况2下，当读入123并赋变量a后，依次匹配并不保存字符<code>x</code> <code>y</code>，然后继续读入456并赋变量b，故变量a为<code>123</code>，变量b为<code>456</code>。</li>
</ul>
<hr>
<h2 id="三-字符残留问题"><a href="#三-字符残留问题" class="headerlink" title="三 字符残留问题"></a>三 字符残留问题</h2><p>&emsp;&emsp;考虑读入完全的情况，在读入完毕后，数据缓冲区仍残留换行符<code>\n</code>。可以从下例验证该结果。<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">char</span> a = <span class="number">0</span>;</span><br><span class="line">	<span class="type">char</span> b = <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//while (i &lt; 2)</span></span><br><span class="line">	<span class="comment">//&#123;</span></span><br><span class="line">	<span class="comment">//	scanf(&quot;%c&quot;, &amp;a);//i=0：输入a；i=1：（无法输入）</span></span><br><span class="line">	<span class="comment">//	printf(&quot;%c&quot;, a);//i=0：得到a；i=1：得到(Newline)</span></span><br><span class="line">	<span class="comment">//	i++;</span></span><br><span class="line">	<span class="comment">//&#125;</span></span><br><span class="line">	<span class="keyword">while</span> (i &lt; <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;a);<span class="comment">//i=0：输入a；i=1：b</span></span><br><span class="line">		<span class="keyword">while</span> (b = getchar() != <span class="string">&#x27;\n&#x27;</span>);<span class="comment">//用以除去换行符</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%c\n&quot;</span>, a);<span class="comment">//i=0：得到a；i=1：得到b</span></span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><div class="note warning flat"><p>&emsp;&emsp;除了采用上述办法解决字符残留问题外，还可以使用<code>fflush(stdin);</code>语句解决之。但是这在高版本的VS中不适用。</p>
</div></p>
]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Fallibility</tag>
        <tag>Exploration</tag>
      </tags>
  </entry>
  <entry>
    <title>C语言 | 递归实践：汉诺塔问题 青蛙跳台阶问题</title>
    <url>/post/6290815e.html</url>
    <content><![CDATA[<h2 id="一-递归的含义及其两个必要条件"><a href="#一-递归的含义及其两个必要条件" class="headerlink" title="一 递归的含义及其两个必要条件"></a>一 递归的含义及其两个必要条件</h2><h3 id="（一）-递归的含义"><a href="#（一）-递归的含义" class="headerlink" title="（一） 递归的含义"></a>（一） 递归的含义</h3><p>&emsp;&emsp;递归，是指一种通过重复将问题分解为同类的子问题而解决问题的方法。它将大事化小，能够大大减少程序的代码量。</p>
<h3 id="（二）-递归的两个必要条件"><a href="#（二）-递归的两个必要条件" class="headerlink" title="（二） 递归的两个必要条件"></a>（二） 递归的两个必要条件</h3><p>&emsp;&emsp;1 存在限制条件，当满足这个限制条件的时候，递归便不再继续；<br>&emsp;&emsp;2 每次递归调用之后越来越接近这个限制条件。</p>
<hr>
<h2 id="二-汉诺塔问题"><a href="#二-汉诺塔问题" class="headerlink" title="二 汉诺塔问题"></a>二 汉诺塔问题</h2><h3 id="（一）-问题内容"><a href="#（一）-问题内容" class="headerlink" title="（一） 问题内容"></a>（一） 问题内容</h3><div class="note info flat"><ul>
<li><b>BASE</b>-在一块铜板装置上，有三根杆(编号A、B、C)，在A杆自下而上、由大到小按顺序放置若干个金盘。（如图I1所示）</li>
<li><b>GOAL</b>-把A杆上的金盘全部移到C杆上，并仍保持原有顺序叠好。</li>
<li><b>RULE</b>-每次只能移动一个盘子，并且在移动过程中三根杆上都始终保持大盘在下，小盘在上，操作过程中盘子可以置于A、B、C任一杆上。</li>
</ul>
</div>
<p><img src="/post/6290815e/C-Language-005-I1.jpg" alt="I1.汉诺塔问题" title="I1.汉诺塔问题"></p>
<h3 id="（二）-解决思路"><a href="#（二）-解决思路" class="headerlink" title="（二） 解决思路"></a>（二） 解决思路</h3><p>&emsp;&emsp;为了满足<code>大盘在下，小盘在上</code>的规则，当金盘进入C杆时，其顺序也应当是<code>先大盘，后小盘</code>。以4个金盘为例，不妨基于C杆考察此问题：<br>&emsp;&emsp;<b>第1轮转移</b> 当第一个金盘进入C杆时，其余盘应按照从小到大置于B杆；（如图I2.a所示）<br>&emsp;&emsp;<b>第2轮转移</b> 当第二个金盘进入C杆时，其余盘应按照从小到大置于A杆；（如图I2.b所示）<br>&emsp;&emsp;<b>第3轮转移</b> 当第三个金盘进入C杆时，其余盘应按照从小到大置于B杆；（如图I2.c所示）<br>&emsp;&emsp;<b>第4轮转移</b> 当第四个金盘进入C杆时，达到目标。（如图I2.d所示）<br><img src="/post/6290815e/C-Language-005-I2.jpg" alt="I2.汉诺塔问题" title="I2.汉诺塔问题操作流程示例"><br>&emsp;&emsp;注意到，总是需要将A杆（或B杆）上的n个金盘中的n-1个转移到B杆（或A杆），然后将第n个金盘转移到C杆。并且在转移n-1个金盘的过程中，也同样遵循上述规律，即将A杆（或B杆）上的n-1个金盘中的n-2个转移到C杆，然后将第n-1金盘转移到B杆（或A杆）。这样一来，不难发现该问题可以分解为同类的子类问题，并且符合递归的必要条件——其限制条件是转移前A杆和B杆的金盘数目都为0；并且每轮结束时，金盘数目都<code>减1</code>，越来越接近限制条件。<br>&emsp;&emsp;基于以上思路进行程序设计。</p>
<h3 id="（三）-解决办法"><a href="#（三）-解决办法" class="headerlink" title="（三） 解决办法"></a>（三） 解决办法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数的传入参数n是A杆放置的金盘数目。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TOH</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//定义返回结果为操作次数。</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//1.递归限制条件：</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//2.递归部分：</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//2.1.将A杆（或B杆）最底盘之上的n-1个盘子移动至B杆（或A杆）上。</span></span><br><span class="line">		ret += TOH(n - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//2.2.将最底盘移动至C杆上。</span></span><br><span class="line">		ret += <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="三-青蛙跳台阶问题"><a href="#三-青蛙跳台阶问题" class="headerlink" title="三 青蛙跳台阶问题"></a>三 青蛙跳台阶问题</h2><h3 id="（一）-问题内容-1"><a href="#（一）-问题内容-1" class="headerlink" title="（一） 问题内容"></a>（一） 问题内容</h3><div class="note info flat"><ul>
<li><b>BASE</b>-有一只青蛙处于若干阶台阶底层。</li>
<li><b>GOAL</b>-青蛙恰好到达台阶顶层。</li>
<li><b>RULE</b>-青蛙每次跳跃的台阶数仅能为1或2。</li>
</ul>
</div>
<h3 id="（二）-解决思路-1"><a href="#（二）-解决思路-1" class="headerlink" title="（二） 解决思路"></a>（二） 解决思路</h3><p>&emsp;&emsp;注意到<code>青蛙每次跳跃的台阶数仅能为1或2</code>，设跳跃的次数为M，台阶数为N，那么当进行第M次跳跃时，也仅能跳跃1阶或2阶；当进行第M-1次跳跃时，已经跳跃的台阶数是N-1或N-2。类似地，当进行第M-2次跳跃时，已经跳跃的台阶数是N-1-1或N-1-2或N-2-1或N-2-2。据此就可以知道，<b>跳跃N<code>(N≥3)</code>阶台阶的跳法总是跳跃N-1阶台阶的跳法与跳跃N-2阶台阶的跳法之和；当N=1时，仅有1种跳法；当N=2时，仅有两种跳法。</b>这便符合了递归的必要条件——其限制条件是跳跃前剩余台阶数为1或2；并且每次跳跃结束时，台阶数目都<code>减1</code>或<code>减2</code>，越来越接近限制条件。<br>&emsp;&emsp;基于以上思路进行程序设计。</p>
<h3 id="（三）-解决办法-1"><a href="#（三）-解决办法-1" class="headerlink" title="（三） 解决办法"></a>（三） 解决办法</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数的传入参数n是台阶数目。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CS</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//定义返回结果为跳法数目。</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">//1.递归限制条件：</span></span><br><span class="line">	<span class="comment">//1.1.台阶数为1时，有1种跳法。</span></span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//1.2.台阶数为2时，有2种跳法。</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//2.递归部分：</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//跳跃n阶台阶的跳法总是跳跃n-1阶台阶的跳法与跳跃n-2阶台阶的跳法之和。</span></span><br><span class="line">		ret = CS(n - <span class="number">1</span>) + CS(n - <span class="number">2</span>);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C语言</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>Exploration</tag>
      </tags>
  </entry>
  <entry>
    <title>算法分析 | 渐进算法分析</title>
    <url>/post/ba640e12.html</url>
    <content><![CDATA[<div class="note info flat"><p>&emsp;&emsp;本博文的所有变量、数字、公式等均采用<code>katex</code>风格。</p>
</div>
<h2 id="一-运行时间代价"><a href="#一-运行时间代价" class="headerlink" title="一 运行时间代价"></a>一 运行时间代价</h2><div class="note info flat"><p><b>一些术语：</b></p>
<ul>
<li><b>规模</b>-一般指输入量的数目。</li>
<li><b>算法代价</b>-指一种算法（或者是实现该算法的一个程序实例）所花费的时间（称为<code>时间代价</code>），以及一种数据结构所占用的空间（称为<code>空间代价</code>）。</li>
<li><b>基本操作</b>-必须具备这样的性质：<b>完成该操作所需时间与操作的数目的具体取值无关</b>。例如在大多数高级语言中两个整数的相加；而$n$个整数的累加便不是基本操作，因为这个操作的时间代价与$n$的大小有关。</li>
</ul>
</div>
<p>&emsp;&emsp;运行速度通常是算法代价的关键方面（<b>但注意运行速度绝非等价于算法代价</b>），因此，算法的性能可以以<b>处理一定规模的输入时该算法所需执行的基本操作的数目</b>作为衡量标准。如果我们要观察算法在不同规模输入的情况下的性能，就可以考虑使用函数$T(n)$（总是假设$T(n)$非负）来描述它。例如对于一个变量$sum$，如果忽略与输入规模无关的部分所消耗的时间（比如变量初始化、循环调节变量的增值等），那么有（以下表达式中$c$为常数）：</p>
<ul>
<li><b>示例一</b> 将一个整数与变量$sum$相加：</li>
</ul>
<blockquote>
<script type="math/tex; mode=display">
T(n)=c</script></blockquote>
<p>&emsp;&emsp;<code>注：这是一种基本操作，其时间代价总是与规模无关，此时称之为常数运行时间。</code></p>
<ul>
<li><b>示例二</b> 将$n$个整数依次与变量$sum$相加：</li>
</ul>
<blockquote>
<script type="math/tex; mode=display">
T(n)=cn</script></blockquote>
<ul>
<li><b>示例三</b> 将$n$个整数依次与变量$sum$相加，并将上述过程重复$n$次：</li>
</ul>
<blockquote>
<script type="math/tex; mode=display">
T(n)=cn^2</script></blockquote>
<hr>
<h2 id="二-增长率"><a href="#二-增长率" class="headerlink" title="二 增长率"></a>二 增长率</h2><p>&emsp;&emsp;根据教材的定义，算法的增长率是指<b>当输入的规模增大时，算法代价的增长速率。</b><br><div class="note warning flat"><p>&emsp;&emsp;博主认为这样的定义是有歧义的。速率一词常见于运动学中，表示运动的快慢，被定义为<b>路程变化量和时间变化量的比值</b>，即</p>
<blockquote>
<script type="math/tex; mode=display">
v = \frac{\Delta s}{\Delta t}</script></blockquote>
<p>&emsp;&emsp;类似地，如果按照速率的定义，则这里算法的增长率被定义为算法代价的变化量和输入规模变化量的比值，即</p>
<blockquote>
<script type="math/tex; mode=display">
r = \frac{\Delta T}{\Delta n}</script></blockquote>
<p>&emsp;&emsp;但是在普遍的定义中，增长率被定义为某一指标的变化量和原来指标的比值，即</p>
<blockquote>
<script type="math/tex; mode=display">
r = \frac{\Delta T}{T_0}</script></blockquote>
<p>&emsp;&emsp;后者定义更加契合它的内涵。例如在以下博文中，可以发现</p>
<ul>
<li>在定义线性、二次、指数增长率时，它们所对应的运行时间函数$T(n)$也是线性、二次、指数的。这意味着从运行时间函数计算增长率的过程中并不降阶；但是如果按照前者定义，则等价于对运行时间函数求导，致使增长率比运行时间函数低阶，这导致矛盾。</li>
<li>在算法的上限、下限的阐述中，<b>运行时间的上限（或下限）</b>和<b>增长率的上限（或上限）</b>这两种说法总是可以交换的，这意味着这二者的最高阶总是一致的（渐进分析忽略了常系数和低阶项），应用前者定义也会产生矛盾。</li>
</ul>
<p>&emsp;&emsp;因此在理解时应当采用后者定义。<br><code>注：限于博主的认知，以上论断可能有误。如果您发现了不当之处，还望在评论区提出您的想法。</code></p>
</div></p>
<ul>
<li>对$T(n)=cn$（$c$为常数）的增长率，称之为<b>线性增长率</b>或者<b>线性时间代价</b>；</li>
<li>对$T(n)$中含有形如$n^2$的高次项的增长率，称之为<b>二次增长率</b>；</li>
<li>对$T(n)=a^n$（$a$为常数且$a&gt;0$）或$T(n)=n!$的增长率，称之为<b>指数增长率</b>。</li>
</ul>
<div class="note success flat"><p>&emsp;&emsp;图$I1$作出了这三类运行时间函数的图像示例，并可以得到以下结论<b>（当规模较大时）</b>：</p>
<ul>
<li>$n^a$的增长率总是快于$log^bn$和$logn^b$（$a,b&gt;1$）；</li>
<li>$a^n$的增长率总是快于$n^b$（$a,b \geq 1$）。</li>
</ul>
<p>&emsp;&emsp;实际上，按照增长速率又快到慢总是有<b>（当规模较大时）</b>：阶乘函数、指数函数、幂函数、$nlogn$、线性函数、对数函数、常函数。注意到总是在强调<b>当规模较大时</b>，这实际上运用了一些渐进分析（将会在后文介绍到）的思想。<br><img src="/post/ba640e12/algorithm-analysis-001-I1.jpg" alt="I1.运行时间函数示例" title="I1.运行时间函数示例"></p>
</div>
<hr>
<h2 id="三-最佳、最差和平均情况"><a href="#三-最佳、最差和平均情况" class="headerlink" title="三 最佳、最差和平均情况"></a>三 最佳、最差和平均情况</h2><p>&emsp;&emsp;即便规模相同，算法的时间代价也可能会因为输入数据不同而不同。算法的最佳情况是指运行时间<b>最短</b>的情形；最差情况是指运行时间<b>最长</b>的情形；平均情况则是分析所有情况下运行时间的平均值。具体考虑哪一种情况依据实际问题和需求确定。实际上，由于最佳情况过于乐观，一般情况并不采用；在实时系统中，比较关注最差情况算法分析；其他情况下则通常考虑平均情况（但需要知道输入数据的分布，否则就只能求助于最差情况分析）。</p>
<hr>
<h2 id="四-渐进分析"><a href="#四-渐进分析" class="headerlink" title="四 渐进分析"></a>四 渐进分析</h2><p>&emsp;&emsp;<b>在输入规模趋近极限的情况下</b>估算增长率时通常会忽略其常数系数。这样的简化分析方式就是<code>渐进算法分析</code>，常用于算法比较。</p>
<h3 id="（一）-上限——“大欧”表示法"><a href="#（一）-上限——“大欧”表示法" class="headerlink" title="（一） 上限——“大欧”表示法"></a>（一） 上限——“大欧”表示法</h3><p>&emsp;&emsp;上限的定义是：</p>
<blockquote>
<p>&emsp;&emsp;对于非负函数$T(n)$，如果存在两个正常数$c$和$c_0$，对任意$n&gt;n_0$，有$T(n) \leq cf(n)$，则称$T(n)$在集合$O(f(n))$中。</p>
</blockquote>
<p>&emsp;&emsp;例如对$T(n)=c_1n^2+c_2n+c_3$（$c_1$、$c_2$、$c_3$均为常数，<code>平均情况下</code>）而言，取$n_0=1$（实际上一般情况下$n_0$都比较小，取使不等式成立的<code>最小值</code>），那么当$n_0&gt;1$时，由$T(n)=c_1n^2+c_2n+c_3 \leq (c_1+c_2+c_3)n^2$分析得知，当取$c=c_1+c_2+c_3$，$n_0=1$时，$T(n) \leq cn^2$成立，则称$T(n)$在集合$O(n^2)$中。<br>&emsp;&emsp;特别地，对$T(n)=c$（$c$为常数），称$T(n)$在集合$O(1)$中。<br>&emsp;&emsp;注意到在定义中，$O(f(n))$是一个集合，它包含了<b>与$f(n))$同阶和比$f(n))$高阶的函数</b>，这意味着上限不止一个。例如，对$T(n)=c_1n^2+c_2n+c_3$（$c_1$、$c_2$、$c_3$均为常数，<code>平均情况下</code>）而言，我们知道这个$T(n)$在集合$O(n^2)$中，并且不难证明$T(n)$在集合$O(n^3)$甚至更高阶的集合中。为了更加精确地描述，应当试图寻找<b>最小</b>的上限，例如上例中，$T(n)$在集合$O(n^2)$中是更好的说法。</p>
<div class="note warning flat"><p>&emsp;&emsp;某一种算法的时间代价函数都具有一定的背景——<code>最佳、最差和平均情况</code>。因此在描述上限（或下限）时，同样应当表明它隶属于哪一种情况。因此，例如对上例而言，应当说<b>这种算法在平均情况下的增长率上限是$n^2$</b>。</p>
</div>
<h3 id="（二）-下限——“大欧米伽”表示法"><a href="#（二）-下限——“大欧米伽”表示法" class="headerlink" title="（二） 下限——“大欧米伽”表示法"></a>（二） 下限——“大欧米伽”表示法</h3><p>&emsp;&emsp;下限的定义是：</p>
<blockquote>
<p>&emsp;&emsp;对于非负函数$T(n)$，如果存在两个正常数$c$和$c_0$，对任意$n&gt;n_0$，有$T(n) \geq cg(n)$，则称$T(n)$在集合$\Omega(g(n))$中。</p>
</blockquote>
<p>&emsp;&emsp;例如对$T(n)=c_1n^2+c_2n+c_3$（$c_1$、$c_2$、$c_3$均为常数，<code>平均情况下</code>）而言，取$n_0=1$（实际上一般情况下$n_0$都比较小，取使不等式成立的<code>最小值</code>），那么当$n_0&gt;1$时，由$T(n)=c_1n^2+c_2n+c_3 \geq c_1n^2$分析得知，当取$c=c_1$，$n_0=1$时，$T(n) \geq cn^2$成立，则称$T(n)$在集合$\Omega(n^2)$中。<br>&emsp;&emsp;特别地，对$T(n)=c$（$c$为常数），称$T(n)$在集合$\Omega(1)$中。<br>&emsp;&emsp;如同“大欧”表示法一样，为了更加精确地描述，应当试图寻找<b>最大</b>的下限。</p>
<h3 id="（三）-“大西塔”表示法"><a href="#（三）-“大西塔”表示法" class="headerlink" title="（三） “大西塔”表示法"></a>（三） “大西塔”表示法</h3><p>&emsp;&emsp;如果一种算法既在$O(h(n))$中，又在$\Omega(h(n))$中，则称其<code>为</code>$\Theta(h(n))$（不再称<code>在……中</code>，因为上下限一致，不会再升阶或降阶）。实际上，如果能够给出一种算法在某种情况下的运行时间函数$T(n)$，那么这种情况下，这种算法的上下限通常都是相等的。<b>只有在不完全清楚待处理任务时，区别上限和下限才有意义</b>。<br><div class="note success flat"><p>&emsp;&emsp;排序问题的最差情况代价为$\Theta(nlogn)$。</p>
</div></p>
<h3 id="（四）-化简法则"><a href="#（四）-化简法则" class="headerlink" title="（四） 化简法则"></a>（四） 化简法则</h3><p>&emsp;&emsp;法则内容如下：</p>
<blockquote>
<p><b>$1$</b> 若$f(n)$在$O(g(n))$中，且$g(n)$在$O(h(n))$中，则$f(n)$在$O(h(n))$中；<br><b>$2$</b> 若$f(n)$在$O(kg(n))$中，对于任意常数$k&gt;0$成立，则$f(n)$在$O(g(n))$中；<br><b>$3$</b> 若$f_1(n)$在$O(g_1(n))$中，且$f_2(n)$在$O(g_2(n))$中，则$f_1(n)+f_2(n)$在$O(max(g_1(n),g_2(n))$中；<br><b>$4$</b> 若$f_1(n)$在$O(g_1(n))$中，且$f_2(n)$在$O(g_2(n))$中，则$f_1(n)f_2(n)$在$O(g_1(n)g_2(n))$中。<br>以上结论对大$\Omega$表示法和大$\Theta$表示法也成立。</p>
</blockquote>
<p>&emsp;&emsp;法则$1$表示，如果$g(n)$是$f(n)$的上限，那么$g(n)$的上限也是$f(n)$的上限。<br>&emsp;&emsp;法则$2$表示，常数因子可被忽略。<br>&emsp;&emsp;法则$3$表示，对于顺序的两组语句或两段代码，只需考虑开销较大的部分。<br>&emsp;&emsp;法则$4$表示，对于一个有限次的循环而言，如果每一次循环的内容的开销相等，那么总开销就是每次的开销与重复次数之积。</p>
<h3 id="（五）-在增长率比较中的应用"><a href="#（五）-在增长率比较中的应用" class="headerlink" title="（五） 在增长率比较中的应用"></a>（五） 在增长率比较中的应用</h3><p>&emsp;&emsp;对于给定的函数$f(n)$和$g(n)$，如果</p>
<blockquote>
<script type="math/tex; mode=display">
\lim\limits_{x\to \infty} \frac{f(n)}{g(n)}</script></blockquote>
<ul>
<li>值趋向$\infty$，则$f(n)$在$\Omega(g(n))$中；</li>
<li>值趋向$0$，则$f(n)$在$O(g(n))$中；</li>
<li>值趋向非$0$常数，则$f(n)=\Theta(g(n))$。</li>
</ul>
<hr>
<h2 id="五-空间代价"><a href="#五-空间代价" class="headerlink" title="五 空间代价"></a>五 空间代价</h2><p>&emsp;&emsp;空间代价是相对于<b>数据结构</b>而言的。渐进分析中增长率的概念对于空间代价同样适用。</p>
<ul>
<li>对于一维数组而言，它的空间代价是$\Theta(n)$；</li>
<li>对于二维数组而言，它的空间代价是$\Theta(n^2)$。<div class="note info flat"><p><b>一些术语：</b></p>
<ul>
<li><b>结构性开销</b>-并非真正数据的附加信息。例如链表中每个元素的指针。理论上，这种结构性开销应当尽可能小，但访问路径应该尽可能多而有效，二者之间需要权衡。</li>
<li><b>基于内存的时间/空间权衡原则</b>-牺牲存储空间来减少时间代价或牺牲时间来减少空间代价。</li>
<li><b>基于磁盘（外存文件）的时间/空间权衡原则</b>-由于从磁盘上读取数据的时间开销往往大于用于计算的时间开销，因此总是减少存储开销来减少时间代价（但并不总是这样）。</li>
</ul>
</div>
&emsp;&emsp;术语中反复提到<code>权衡</code>二字，这引导我们在设计程序时应当同时关注所权衡的二者的利害关系，试图寻找最适合实际情况的办法。</li>
</ul>
<hr>
<div class="note warning flat"><p>&emsp;&emsp;最后忠告：<br>&emsp;&emsp;<b>先调整算法，后调整代码！</b></p>
</div>
]]></content>
      <categories>
        <category>算法分析</category>
      </categories>
      <tags>
        <tag>Algorithm Analysis</tag>
      </tags>
  </entry>
  <entry>
    <title>博客基建 | 创建或修改博客的常用Hexo命令</title>
    <url>/post/74158de9.html</url>
    <content><![CDATA[<h2 id="一-创建新的博文"><a href="#一-创建新的博文" class="headerlink" title="一 创建新的博文"></a>一 创建新的博文</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;Title&quot;</span> //<span class="string">&quot;Title&quot;</span>是新建博文的标题，引号内部内容可以替换</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;更多信息，请 <a href="https://hexo.io/docs/writing.html">单击此处</a> 访问。</p>
<hr>
<h2 id="二-运行服务器"><a href="#二-运行服务器" class="headerlink" title="二 运行服务器"></a>二 运行服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server //亦或hexo s</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;然后访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 在本地预览效果。预览结束后，使用<code>Ctrl+C</code>停止。<br>&emsp;&emsp;更多信息，请 <a href="https://hexo.io/docs/server.html">单击此处</a> 访问。</p>
<hr>
<h2 id="三-部署博文"><a href="#三-部署博文" class="headerlink" title="三 部署博文"></a>三 部署博文</h2><p>&emsp;&emsp;博文撰写完毕后或<b>每次修改结束后</b>，都应当执行以下三条命令以部署。以下三条命令又称<code>hexo三联</code>。</p>
<h3 id="（一）-删除原有的public文件夹"><a href="#（一）-删除原有的public文件夹" class="headerlink" title="（一） 删除原有的public文件夹"></a>（一） 删除原有的public文件夹</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean //亦或hexo cl</span><br></pre></td></tr></table></figure>
<h3 id="（二）-生成新的public文件夹"><a href="#（二）-生成新的public文件夹" class="headerlink" title="（二） 生成新的public文件夹"></a>（二） 生成新的public文件夹</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate //亦或hexo g</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;更多信息，请 <a href="https://hexo.io/docs/generating.html">单击此处</a> 访问。</p>
<h3 id="（三）-部署到远程站点"><a href="#（三）-部署到远程站点" class="headerlink" title="（三） 部署到远程站点"></a>（三） 部署到远程站点</h3><div class="note warning flat"><p>&emsp;&emsp;部署到远程站点前，建议运行服务器在本地预览效果。当确认无误后，将博文部署到远程站点。</p>
</div>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy //亦或hexo d</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;更多信息，请 <a href="https://hexo.io/docs/one-command-deployment.html">单击此处</a> 访问。</p>
<div class="note info flat"><p>&emsp;&emsp;以上三步可以简化为以下代码。<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean&amp;&amp;hexo generate --deploy //亦或hexo cl&amp;&amp;hexo g -d</span><br></pre></td></tr></table></figure><br>&emsp;&emsp;或者<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean&amp;&amp;hexo deploy --generate //亦或hexo cl&amp;&amp;hexo d -g</span><br></pre></td></tr></table></figure></p>
</div>
]]></content>
      <categories>
        <category>博客基建</category>
      </categories>
      <tags>
        <tag>Common</tag>
      </tags>
  </entry>
  <entry>
    <title>博客基建 | 博客搭建更新日志</title>
    <url>/post/b74865a7.html</url>
    <content><![CDATA[<h2 id="2023-7-23更新日志"><a href="#2023-7-23更新日志" class="headerlink" title="2023-7-23更新日志"></a>2023-7-23更新日志</h2><h3 id="1-重要更新"><a href="#1-重要更新" class="headerlink" title="1 重要更新"></a>1 重要更新</h3><h4 id="1-1-新增页面-友链"><a href="#1-1-新增页面-友链" class="headerlink" title="1.1 新增页面-友链"></a>1.1 新增页面-友链</h4><blockquote>
<p>&emsp;&emsp;置身于信息世界的广阔天地，踽踽独行难媲集思广益。未来立足于过往，每一位奋斗者都值得被铭记。您现在可以在<code>友链</code>页面查看同行者，他们的不断探究和经验分享促成了如今博客的繁花似锦。</p>
<h3 id="2-其它更新"><a href="#2-其它更新" class="headerlink" title="2 其它更新"></a>2 其它更新</h3><h4 id="2-1-优化感官-页面简化"><a href="#2-1-优化感官-页面简化" class="headerlink" title="2.1 优化感官-页面简化"></a>2.1 优化感官-页面简化</h4><p>&emsp;&emsp;此前的页面背景过于纷繁复杂，降低了访客的视觉体验；同时过多的资源加载降低了网页载入速率，延长了访客的等待时间。这不符合博客的工具性。因此，本次更新通过放弃部分效果以获得更直观清晰的访问体验。</p>
</blockquote>
<hr>
<h2 id="2023-5-10更新日志"><a href="#2023-5-10更新日志" class="headerlink" title="2023-5-10更新日志"></a>2023-5-10更新日志</h2><h3 id="1-重要更新-1"><a href="#1-重要更新-1" class="headerlink" title="1 重要更新"></a>1 重要更新</h3><h4 id="1-1-新增功能-搜索"><a href="#1-1-新增功能-搜索" class="headerlink" title="1.1 新增功能-搜索"></a>1.1 新增功能-搜索</h4><blockquote>
<p>&emsp;&emsp;您现在可以单击导航栏的<code>放大镜</code>按钮唤起搜索弹窗，输入关键词以查找相关博文。</p>
<h4 id="1-2-优化功能-评论"><a href="#1-2-优化功能-评论" class="headerlink" title="1.2 优化功能-评论"></a>1.2 优化功能-评论</h4><p>&emsp;&emsp;为了提供更方便的评论服务，评论系统由Valine变更为Waline。<br>&emsp;&emsp;您现在可以单击评论栏底部的<code>登录</code>按钮进入登录页面登录您的账号，以享受个性化的评论服务。您可选用的登录方式包括但不仅限于<b>QQ/微博/Github</b>。</p>
</blockquote>
<div class="note info flat"><ul>
<li>如果您在昵称处输入了您的QQ账号，您的头像将设置为与QQ相同；</li>
<li>如果您在邮箱处输入了您的QQ邮箱，您的昵称和头像将设置为与QQ相同；</li>
<li>如果您采用QQ登录，您的昵称和头像将设置为与QQ相同。</li>
</ul>
</div>
<h3 id="2-其它更新-1"><a href="#2-其它更新-1" class="headerlink" title="2 其它更新"></a>2 其它更新</h3><h4 id="2-1-优化感官-加载速率"><a href="#2-1-优化感官-加载速率" class="headerlink" title="2.1 优化感官-加载速率"></a>2.1 优化感官-加载速率</h4><blockquote>
<p>&emsp;&emsp;博客加载速度过慢致使访问体验降低。因此，本次更新通过尝试不同的部署进一步优化了博客加载速率。加载速率具有地区差异性。</p>
</blockquote>
<div class="note success flat"><p>&emsp;&emsp;以下为您提供了三个链接，您可以尝试访问其中任意一个，收藏其中加载速率较快的一个。</p>
<ul>
<li><a href="https://www.dawn-of-time.top/">https://www.dawn-of-time.top/</a><b>（推荐）</b></li>
<li><a href="https://netlify.dawn-of-time.top/">https://netlify.dawn-of-time.top/</a></li>
<li><a href="https://dawn-of-time.github.io/">https://dawn-of-time.github.io/</a><b>（不推荐）</b></li>
</ul>
</div>
<hr>
<h2 id="2023-5-9更新日志"><a href="#2023-5-9更新日志" class="headerlink" title="2023-5-9更新日志"></a>2023-5-9更新日志</h2><h3 id="1-重要更新-2"><a href="#1-重要更新-2" class="headerlink" title="1 重要更新"></a>1 重要更新</h3><h4 id="1-1-新增功能-评论"><a href="#1-1-新增功能-评论" class="headerlink" title="1.1 新增功能-评论"></a>1.1 新增功能-评论</h4><blockquote>
<p>&emsp;&emsp;评论功能的作用包括但不限于：</p>
<ul>
<li>向我提出疑问、修改建议或者告知侵权内容（如果有）；</li>
<li>与我和其他访客交流有关博文内容的学习经验。</li>
</ul>
<p>&emsp;&emsp;<b>评论内容应当遵循至少以下规定：</b></p>
<ul>
<li>一 严禁散布谣言，谎报险情、疫情、警情或者以其他方法故意扰乱公共秩序；</li>
<li>二 严禁分享除与博文内容相关的第三方链接，包括但不限于广告、刷单、赌博等；</li>
<li>三 严禁挑衅、辱骂、诋毁、攻击作者和其他访客；</li>
<li>四 严禁谈论政治话题。</li>
</ul>
</blockquote>
<p> <div class="note danger flat"><p>&emsp;&emsp;本规定即日起执行。若有违反者，我将依据以上规定删除有关评论。<br>&emsp;&emsp;未尽事宜，后续补充。</p>
</div>&lt;/b&gt;</p>
]]></content>
      <categories>
        <category>博客基建</category>
      </categories>
      <tags>
        <tag>Update</tag>
      </tags>
  </entry>
</search>
